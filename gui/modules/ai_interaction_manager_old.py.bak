#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AIäº¤äº’ç®¡ç†å™¨ (å¢å¼ºç‰ˆ)
è´Ÿè´£ç®¡ç†AIåŠ©æ‰‹çª—å£ã€å³é”®èœå•å’Œæ—¥å¿—ä¸Šä¸‹æ–‡åˆ†æåŠŸèƒ½

æ–°å¢åŠŸèƒ½:
- æ™ºèƒ½ä¸Šä¸‹æ–‡æå– (æ ¹æ®é—®é¢˜ç±»å‹è‡ªåŠ¨è°ƒæ•´)
- æ—¥å¿—å¯¼èˆªä¸è·³è½¬ (AIåˆ†æç»“æœâ†’æ—¥å¿—ä½ç½®)
- åˆ†æç»“æœç¼“å­˜ (é¿å…é‡å¤åˆ†æ)
"""

import tkinter as tk
from tkinter import messagebox, ttk
from typing import Optional, Tuple, List, Any

# å¯¼å…¥æ–°å¢çš„æ™ºèƒ½åŠŸèƒ½æ¨¡å—
try:
    from .ai_diagnosis.smart_context_extractor import SmartContextExtractor
    from .ai_diagnosis.log_navigator import LogNavigator, AIAnalysisParser
    from .ai_diagnosis.analysis_cache import get_global_cache
    SMART_FEATURES_AVAILABLE = True
except ImportError:
    SMART_FEATURES_AVAILABLE = False
    print("âš ï¸  æ™ºèƒ½AIåŠŸèƒ½æ¨¡å—æœªåŠ è½½")


class AIInteractionManager:
    """AIäº¤äº’ç®¡ç†å™¨ - å¤„ç†AIåŠ©æ‰‹çš„æ‰€æœ‰äº¤äº’é€»è¾‘"""

    def __init__(self, parent_app):
        """
        åˆå§‹åŒ–AIäº¤äº’ç®¡ç†å™¨

        Args:
            parent_app: çˆ¶åº”ç”¨ç¨‹åºå®ä¾‹(MarsLogAnalyzerPro)
        """
        self.app = parent_app
        self.ai_assistant = None
        self.ai_window = None
        self.log_context_menu = None

        # æ–°å¢: æ™ºèƒ½åŠŸèƒ½ç»„ä»¶
        self.navigator = None           # æ—¥å¿—å¯¼èˆªå™¨
        self.context_extractor = None   # æ™ºèƒ½ä¸Šä¸‹æ–‡æå–å™¨
        self.analysis_cache = None      # åˆ†æç»“æœç¼“å­˜

        # åˆå§‹åŒ–æ™ºèƒ½åŠŸèƒ½
        if SMART_FEATURES_AVAILABLE:
            self._init_smart_features()

    def _init_smart_features(self) -> None:
        """åˆå§‹åŒ–æ™ºèƒ½åŠŸèƒ½ç»„ä»¶"""
        try:
            # åˆå§‹åŒ–æ—¥å¿—å¯¼èˆªå™¨
            if hasattr(self.app, 'log_text'):
                all_entries = getattr(self.app, 'log_entries', [])
                self.navigator = LogNavigator(self.app.log_text, all_entries)
                print("âœ“ æ—¥å¿—å¯¼èˆªå™¨å·²åˆå§‹åŒ–")

            # åˆå§‹åŒ–åˆ†æç¼“å­˜
            self.analysis_cache = get_global_cache()
            print("âœ“ AIåˆ†æç¼“å­˜å·²åˆå§‹åŒ–")

        except Exception as e:
            print(f"âš ï¸  æ™ºèƒ½åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥: {e}")

    def setup_ai_features(self) -> None:
        """è®¾ç½®AIåŠŸèƒ½ï¼ˆæŒ‰é’®å’Œå³é”®èœå•ï¼‰"""
        # å»¶è¿Ÿæ‰§è¡Œä»¥ç¡®ä¿çˆ¶ç±»UIå·²å®Œæˆåˆ›å»º
        self.app.root.after(100, self._add_button_delayed)
        self.setup_context_menu()

        # å»¶è¿Ÿåˆå§‹åŒ–å¯¼èˆªå™¨ (ç­‰å¾…log_textåˆ›å»º)
        if SMART_FEATURES_AVAILABLE and self.navigator is None:
            self.app.root.after(500, self._init_smart_features)

        # è®¾ç½®å¯¼èˆªå¿«æ·é”®
        self.setup_navigation_shortcuts()

    def _add_button_delayed(self) -> None:
        """å»¶è¿Ÿæ·»åŠ AIåŠ©æ‰‹æŒ‰é’®åˆ°å·¥å…·æ """
        try:
            # æŸ¥æ‰¾search_frameï¼ˆæœç´¢ä¸è¿‡æ»¤çš„LabelFrameï¼‰
            if hasattr(self.app, 'log_frame'):
                for widget in self.app.log_frame.winfo_children():
                    # ç¬¬ä¸€å±‚ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯Frameæˆ–LabelFrame
                    if isinstance(widget, (tk.Frame, ttk.Frame, tk.LabelFrame, ttk.LabelFrame)):
                        # æ£€æŸ¥æ˜¯å¦æ˜¯æœç´¢ä¸è¿‡æ»¤æ¡†
                        try:
                            if widget.cget('text') == 'æœç´¢ä¸è¿‡æ»¤':
                                # æ‰¾åˆ°äº†ï¼Œæ·»åŠ AIåŠ©æ‰‹æŒ‰é’®
                                ai_button = ttk.Button(
                                    widget,
                                    text="ğŸ¤– AIåŠ©æ‰‹",
                                    command=self.open_ai_assistant_window
                                )
                                # æ”¾åœ¨ç¬¬2è¡Œç¬¬9åˆ—
                                ai_button.grid(row=1, column=9, padx=2, pady=3, sticky='w')
                                print("âœ… AIåŠ©æ‰‹æŒ‰é’®å·²æ·»åŠ åˆ°å·¥å…·æ ")
                                return
                        except (tk.TclError, AttributeError):
                            pass

                        # é€’å½’æ£€æŸ¥å­æ§ä»¶
                        for child in widget.winfo_children():
                            if isinstance(child, (tk.LabelFrame, ttk.LabelFrame)):
                                try:
                                    if child.cget('text') == 'æœç´¢ä¸è¿‡æ»¤':
                                        # æ·»åŠ AIåŠ©æ‰‹æŒ‰é’®
                                        ai_button = ttk.Button(
                                            child,
                                            text="ğŸ¤– AIåŠ©æ‰‹",
                                            command=self.open_ai_assistant_window
                                        )
                                        ai_button.grid(row=1, column=9, padx=2, pady=3, sticky='w')
                                        print("âœ… AIåŠ©æ‰‹æŒ‰é’®å·²æ·»åŠ åˆ°å·¥å…·æ ")
                                        return
                                except (tk.TclError, AttributeError):
                                    continue

            print("âš ï¸  æœªæ‰¾åˆ°æœç´¢è¿‡æ»¤åŒºåŸŸï¼Œå°è¯•æ·»åŠ åˆ°ä¸»çª—å£")
            # å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•åœ¨ä¸»èœå•æ·»åŠ 
            self._add_to_menu()

        except Exception as e:
            print(f"âŒ æ·»åŠ æŒ‰é’®å¤±è´¥: {str(e)}")
            import traceback
            traceback.print_exc()

    def _add_to_menu(self) -> None:
        """ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆï¼Œæ·»åŠ åˆ°èœå•æ """
        try:
            if hasattr(self.app, 'menu_bar'):
                # åˆ›å»ºAIåŠ©æ‰‹èœå•
                ai_menu = tk.Menu(self.app.menu_bar, tearoff=0)
                ai_menu.add_command(
                    label="æ‰“å¼€AIåŠ©æ‰‹",
                    command=self.open_ai_assistant_window
                )
                self.app.menu_bar.add_cascade(label="ğŸ¤– AI", menu=ai_menu)
                print("âœ… AIåŠ©æ‰‹å·²æ·»åŠ åˆ°èœå•æ ")
        except Exception as e:
            print(f"âŒ æ·»åŠ åˆ°èœå•å¤±è´¥: {str(e)}")

    def open_ai_assistant_window(self) -> None:
        """æ‰“å¼€AIåŠ©æ‰‹çª—å£"""
        try:
            # å¦‚æœçª—å£å·²å­˜åœ¨ï¼Œç›´æ¥æ˜¾ç¤º
            if self.ai_window and self.ai_window.winfo_exists():
                self.ai_window.deiconify()
                self.ai_window.lift()
                return

            # å¯¼å…¥AIåŠ©æ‰‹é¢æ¿
            try:
                from modules.ai_assistant import AIAssistantPanel
            except ImportError:
                from gui.modules.ai_assistant import AIAssistantPanel

            # åˆ›å»ºæ–°çª—å£
            self.ai_window = tk.Toplevel(self.app.root)
            self.ai_window.title("AIæ™ºèƒ½è¯Šæ–­åŠ©æ‰‹")
            self.ai_window.geometry("500x700")

            # è®¾ç½®çª—å£å›¾æ ‡
            try:
                self.ai_window.iconbitmap(self.app.root.iconbitmap())
            except:
                pass

            # åˆ›å»ºAIåŠ©æ‰‹é¢æ¿
            self.ai_assistant = AIAssistantPanel(self.ai_window, self.app)

            # çª—å£å…³é—­æ—¶éšè—è€Œä¸æ˜¯é”€æ¯
            self.ai_window.protocol("WM_DELETE_WINDOW", self.ai_window.withdraw)

        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"æ— æ³•æ‰“å¼€AIåŠ©æ‰‹çª—å£: {str(e)}")
            import traceback
            traceback.print_exc()

    def setup_context_menu(self) -> None:
        """è®¾ç½®æ—¥å¿—æŸ¥çœ‹å™¨çš„å³é”®èœå•"""
        try:
            # åˆ›å»ºå³é”®èœå•
            self.log_context_menu = tk.Menu(self.app.log_text, tearoff=0)

            # æ·»åŠ AIåˆ†æèœå•é¡¹
            self.log_context_menu.add_command(
                label="ğŸ¤– AIåˆ†ææ­¤æ—¥å¿—",
                command=self.ai_analyze_selected_log
            )
            self.log_context_menu.add_command(
                label="ğŸ¤– AIè§£é‡Šé”™è¯¯åŸå› ",
                command=self.ai_explain_error
            )
            self.log_context_menu.add_command(
                label="ğŸ¤– AIæŸ¥æ‰¾ç›¸å…³æ—¥å¿—",
                command=self.ai_find_related_logs
            )

            self.log_context_menu.add_separator()

            # å¯¼èˆªåŠŸèƒ½
            if SMART_FEATURES_AVAILABLE:
                self.log_context_menu.add_command(
                    label="ğŸ“Š æŸ¥çœ‹é—®é¢˜é“¾è·¯å›¾",
                    command=self.show_problem_graph
                )
                self.log_context_menu.add_command(
                    label="ğŸ“ˆ æŸ¥çœ‹ç¼“å­˜ç»Ÿè®¡",
                    command=self.show_cache_dashboard
                )
                self.log_context_menu.add_separator()

            # æ·»åŠ æ ‡å‡†æ“ä½œ
            self.log_context_menu.add_command(
                label="ğŸ“‹ å¤åˆ¶",
                command=self.copy_selected_text
            )
            self.log_context_menu.add_command(
                label="ğŸ” æœç´¢æ­¤å†…å®¹",
                command=self.search_selected_text
            )

            # ç»‘å®šå³é”®ç‚¹å‡»äº‹ä»¶
            self.app.log_text.bind("<Button-3>", self.show_context_menu)
            self.app.log_text.bind("<Button-2>", self.show_context_menu)  # macOS
            self.app.log_text.bind("<Control-Button-1>", self.show_context_menu)  # macOS

        except Exception as e:
            print(f"å³é”®èœå•è®¾ç½®å¤±è´¥: {str(e)}")

    def show_context_menu(self, event: tk.Event) -> None:
        """æ˜¾ç¤ºå³é”®èœå•"""
        try:
            self.log_context_menu.post(event.x_root, event.y_root)
        except Exception as e:
            print(f"æ˜¾ç¤ºå³é”®èœå•å¤±è´¥: {str(e)}")

    def get_selected_log_context(self) -> Tuple[Any, List, List]:
        """
        è·å–é€‰ä¸­æ—¥å¿—åŠå…¶ä¸Šä¸‹æ–‡

        Returns:
            (target_entry, context_before, context_after)
        """
        try:
            # è·å–é€‰ä¸­çš„æ–‡æœ¬
            if self.app.log_text.tag_ranges("sel"):
                selected_text = self.app.log_text.get("sel.first", "sel.last")
            else:
                # å¦‚æœæ²¡æœ‰é€‰ä¸­ï¼Œè·å–å½“å‰è¡Œ
                current_line = self.app.log_text.index("insert").split('.')[0]
                selected_text = self.app.log_text.get(f"{current_line}.0", f"{current_line}.end")

            if not selected_text.strip():
                return None, None, None

            # ä»filtered_entriesä¸­æŸ¥æ‰¾åŒ¹é…çš„æ—¥å¿—
            entries = getattr(self.app, 'filtered_entries', None) or self.app.log_entries
            matched_entries = [
                entry for entry in entries
                if selected_text.strip() in entry.content or selected_text.strip() in entry.raw_line
            ]

            if not matched_entries:
                return selected_text, [], []

            # è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„æ—¥å¿—å’Œä¸Šä¸‹æ–‡
            target_entry = matched_entries[0]
            all_entries = self.app.log_entries

            try:
                target_idx = all_entries.index(target_entry)
            except ValueError:
                return selected_text, [], []

            # è·å–ä¸Šä¸‹æ–‡ï¼ˆå‰åå„5æ¡ï¼‰
            context_before = all_entries[max(0, target_idx-5):target_idx]
            context_after = all_entries[target_idx+1:min(len(all_entries), target_idx+6)]

            return target_entry, context_before, context_after

        except Exception as e:
            print(f"è·å–æ—¥å¿—ä¸Šä¸‹æ–‡å¤±è´¥: {str(e)}")
            return None, None, None

    def ai_analyze_selected_log(self, log_text: Optional[str] = None) -> None:
        """
        AIåˆ†æé€‰ä¸­çš„æ—¥å¿—

        Args:
            log_text: å¯é€‰çš„æ—¥å¿—æ–‡æœ¬ã€‚å¦‚æœæä¾›ï¼Œç›´æ¥åˆ†æè¯¥æ–‡æœ¬ï¼›å¦åˆ™è·å–é€‰ä¸­çš„æ—¥å¿—
        """
        if not self.ai_assistant:
            self.open_ai_assistant_window()
            self.app.root.after(200, lambda: self._do_ai_analyze(log_text))
            return

        self._do_ai_analyze(log_text)

    def _do_ai_analyze(self, log_text: Optional[str] = None) -> None:
        """æ‰§è¡ŒAIåˆ†æï¼ˆå†…éƒ¨æ–¹æ³• - å¢å¼ºç‰ˆï¼‰"""
        if not self.ai_assistant:
            messagebox.showwarning("è­¦å‘Š", "AIåŠ©æ‰‹åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»'ğŸ¤– AIåŠ©æ‰‹'æŒ‰é’®")
            return

        if log_text is not None:
            # ç›´æ¥åˆ†ææä¾›çš„æ–‡æœ¬
            question = f"åˆ†æä»¥ä¸‹æ—¥å¿—çš„é—®é¢˜å’ŒåŸå› ï¼š\n\n{log_text[:500]}"

            # æ£€æŸ¥ç¼“å­˜
            if self.analysis_cache:
                cached_result = self.analysis_cache.get(question)
                if cached_result:
                    print("âœ“ AIåˆ†æç¼“å­˜å‘½ä¸­!")
                    # TODO: æ˜¾ç¤ºç¼“å­˜ç»“æœåˆ°AIåŠ©æ‰‹ç•Œé¢
                    self.ai_assistant.chat_panel.question_var.set(question)
                    # å¯ä»¥ç›´æ¥è®¾ç½®ç­”æ¡ˆè€Œä¸æ˜¯è°ƒç”¨ask_question
                    return

            self.ai_assistant.chat_panel.question_var.set(question)
            self.ai_assistant.ask_question()
            return

        # ä½¿ç”¨æ™ºèƒ½ä¸Šä¸‹æ–‡æå– (æ–°åŠŸèƒ½)
        if SMART_FEATURES_AVAILABLE and self.context_extractor is None:
            # å»¶è¿Ÿåˆå§‹åŒ–ä¸Šä¸‹æ–‡æå–å™¨
            all_entries = getattr(self.app, 'log_entries', [])
            indexer = getattr(self.app, 'filter_manager', None)
            if indexer:
                indexer = getattr(indexer, 'indexer', None)

            self.context_extractor = SmartContextExtractor(all_entries, indexer)

        # è·å–é€‰ä¸­æ—¥å¿—
        target, context_before, context_after = self.get_selected_log_context()

        if not target:
            messagebox.showinfo("æç¤º", "è¯·é€‰æ‹©è¦åˆ†æçš„æ—¥å¿—")
            return

        # ä½¿ç”¨æ™ºèƒ½ä¸Šä¸‹æ–‡æå–
        if self.context_extractor:
            try:
                smart_context = self.context_extractor.extract_context(target, max_tokens=8000)

                # æ„å»ºä¼˜åŒ–åçš„é—®é¢˜
                question = f"""ã€é—®é¢˜ç±»å‹ã€‘: {smart_context['problem_type'].value}
ã€ç›®æ ‡æ—¥å¿—ã€‘: {self._get_entry_content(target)}

{smart_context['summary']}
"""

                # æ·»åŠ ä¸Šä¸‹æ–‡
                if smart_context['context_before']:
                    question += "\nã€å‰ç½®ä¸Šä¸‹æ–‡ã€‘:\n"
                    for entry in smart_context['context_before'][-5:]:
                        question += f"[{getattr(entry, 'level', 'INFO')}] {self._get_entry_content(entry)[:150]}\n"

                if smart_context['context_after']:
                    question += "\nã€åç½®ä¸Šä¸‹æ–‡ã€‘:\n"
                    for entry in smart_context['context_after'][:3]:
                        question += f"[{getattr(entry, 'level', 'INFO')}] {self._get_entry_content(entry)[:150]}\n"

                # æ·»åŠ ç´¢å¼•å…³è”çš„æ—¥å¿—
                if smart_context.get('related_logs'):
                    question += f"\nã€ç´¢å¼•å…³è” - {len(smart_context['related_logs'])}æ¡ç›¸å…³æ—¥å¿—ã€‘:\n"
                    for entry in smart_context['related_logs'][:5]:
                        question += f"  â€¢ {self._get_entry_content(entry)[:100]}\n"

                print(f"âœ“ æ™ºèƒ½ä¸Šä¸‹æ–‡æå–å®Œæˆ: {smart_context['problem_type'].value}")

            except Exception as e:
                print(f"âš ï¸  æ™ºèƒ½ä¸Šä¸‹æ–‡æå–å¤±è´¥,ä½¿ç”¨ä¼ ç»Ÿæ–¹å¼: {e}")
                question = self._build_traditional_context(target, context_before, context_after)
        else:
            # é™çº§åˆ°ä¼ ç»Ÿæ–¹å¼
            question = self._build_traditional_context(target, context_before, context_after)

        # æ£€æŸ¥ç¼“å­˜
        if self.analysis_cache:
            cached_result = self.analysis_cache.get(question)
            if cached_result:
                print("âœ“ AIåˆ†æç¼“å­˜å‘½ä¸­!")
                # TODO: æ˜¾ç¤ºç¼“å­˜ç»“æœ

        self.ai_assistant.chat_panel.question_var.set(question)
        self.ai_assistant.ask_question()

    def _build_traditional_context(self, target, context_before, context_after) -> str:
        """ä¼ ç»Ÿæ–¹å¼æ„å»ºä¸Šä¸‹æ–‡ (é™çº§æ–¹æ¡ˆ)"""
        params = self.ai_assistant.get_context_params() if self.ai_assistant else {}
        context_limit = params.get('crash_before', 5)

        if isinstance(target, str):
            return f"åˆ†æè¿™æ¡æ—¥å¿—:\n{target}"

        context_info = ""
        if context_before:
            context_info += f"\n\nã€ä¸Šä¸‹æ–‡ - å‰{min(len(context_before), context_limit)}æ¡æ—¥å¿—ã€‘:\n"
            for entry in context_before[-context_limit:]:
                context_info += f"[{entry.level}] {entry.content[:200]}\n"

        question = f"åˆ†æè¿™æ¡{target.level}æ—¥å¿—:\nã€ç›®æ ‡æ—¥å¿—ã€‘: {target.content}"
        if context_info:
            question += context_info

        return question

    def _get_entry_content(self, entry) -> str:
        """è·å–æ—¥å¿—æ¡ç›®å†…å®¹"""
        if isinstance(entry, str):
            return entry
        return getattr(entry, 'content', str(entry))

    def ai_explain_error(self, log_text: Optional[str] = None) -> None:
        """
        AIè§£é‡Šé”™è¯¯åŸå› 

        Args:
            log_text: å¯é€‰çš„æ—¥å¿—æ–‡æœ¬
        """
        if not self.ai_assistant:
            self.open_ai_assistant_window()
            self.app.root.after(200, lambda: self._do_ai_explain(log_text))
            return

        self._do_ai_explain(log_text)

    def _do_ai_explain(self, log_text: Optional[str] = None) -> None:
        """æ‰§è¡ŒAIé”™è¯¯è§£é‡Šï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰"""
        if not self.ai_assistant:
            messagebox.showwarning("è­¦å‘Š", "AIåŠ©æ‰‹åˆå§‹åŒ–å¤±è´¥")
            return

        if log_text is not None:
            question = f"è§£é‡Šä»¥ä¸‹é”™è¯¯çš„åŸå› ã€å½±å“å’Œè§£å†³æ–¹æ¡ˆï¼š\n\n{log_text[:500]}"
            self.ai_assistant.chat_panel.question_var.set(question)
            self.ai_assistant.ask_question()
            return

        target, context_before, context_after = self.get_selected_log_context()

        if not target:
            messagebox.showinfo("æç¤º", "è¯·é€‰æ‹©è¦è§£é‡Šçš„é”™è¯¯")
            return

        # è·å–ä¸Šä¸‹æ–‡å‚æ•°
        params = self.ai_assistant.get_context_params()
        before_limit = params.get('crash_before', 5)
        after_limit = params.get('crash_after', 3)

        # æ„å»ºé—®é¢˜
        if isinstance(target, str):
            question = f"è§£é‡Šè¿™ä¸ªé”™è¯¯çš„åŸå› å’Œå¦‚ä½•ä¿®å¤:\n{target}"
        else:
            context_info = ""
            if context_before:
                context_info += f"\n\nã€ä¸Šä¸‹æ–‡ - å‰{min(len(context_before), before_limit)}æ¡æ—¥å¿—ã€‘:\n"
                for entry in context_before[-before_limit:]:
                    context_info += f"[{entry.level}] {entry.content[:200]}\n"

            if context_after:
                context_info += f"\n\nã€ä¸Šä¸‹æ–‡ - å{min(len(context_after), after_limit)}æ¡æ—¥å¿—ã€‘:\n"
                for entry in context_after[:after_limit]:
                    context_info += f"[{entry.level}] {entry.content[:200]}\n"

            question = f"è§£é‡Šè¿™ä¸ª{target.level}çš„åŸå› å’Œå¦‚ä½•ä¿®å¤:\nã€ç›®æ ‡æ—¥å¿—ã€‘: {target.content}"
            if context_info:
                question += context_info

        self.ai_assistant.chat_panel.question_var.set(question)
        self.ai_assistant.ask_question()

    def ai_find_related_logs(self) -> None:
        """AIæŸ¥æ‰¾ç›¸å…³æ—¥å¿—"""
        if not self.ai_assistant:
            self.open_ai_assistant_window()
            self.app.root.after(200, self._do_ai_find_related)
            return

        self._do_ai_find_related()

    def _do_ai_find_related(self) -> None:
        """æ‰§è¡ŒAIæŸ¥æ‰¾ç›¸å…³æ—¥å¿—ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰"""
        if not self.ai_assistant:
            messagebox.showwarning("è­¦å‘Š", "AIåŠ©æ‰‹åˆå§‹åŒ–å¤±è´¥")
            return

        target, context_before, context_after = self.get_selected_log_context()

        if not target:
            messagebox.showinfo("æç¤º", "è¯·é€‰æ‹©å‚è€ƒæ—¥å¿—")
            return

        # è·å–æœç´¢èŒƒå›´å‚æ•°
        params = self.ai_assistant.get_context_params()
        search_limit = params.get('search_logs', 500)

        # æ„å»ºé—®é¢˜
        if isinstance(target, str):
            question = f"åœ¨æ—¥å¿—ä¸­æŸ¥æ‰¾ä¸æ­¤ç›¸å…³çš„å…¶ä»–æ—¥å¿—:\n{target}"
        else:
            context_info = ""

            try:
                all_entries = getattr(self.app, 'log_entries', [])
                target_idx = all_entries.index(target)

                # è·å–å‰åæ—¥å¿—ä½œä¸ºæœç´¢èŒƒå›´
                half = search_limit // 2
                start = max(0, target_idx - half)
                end = min(len(all_entries), target_idx + half)
                sample_logs = all_entries[start:end]

                if sample_logs:
                    context_info += f"\n\nã€æœç´¢èŒƒå›´ - å…±{len(sample_logs)}æ¡æ—¥å¿—ã€‘:\n"
                    # æ˜¾ç¤ºå‰åå„10æ¡æ ·æœ¬
                    for entry in sample_logs[:10]:
                        context_info += f"[{entry.level}] {entry.content[:150]}\n"

                    if len(sample_logs) > 20:
                        context_info += f"... (ä¸­é—´çœç•¥{len(sample_logs) - 20}æ¡)\n"

                    for entry in sample_logs[-10:]:
                        context_info += f"[{entry.level}] {entry.content[:150]}\n"

            except (ValueError, AttributeError):
                pass

            question = f"åœ¨æ—¥å¿—ä¸­æŸ¥æ‰¾ä¸æ­¤{target.level}ç›¸å…³çš„å…¶ä»–æ—¥å¿—:\nã€ç›®æ ‡æ—¥å¿—ã€‘: {target.content}"
            if context_info:
                question += context_info
            else:
                question += "\n\nè¯·åœ¨å½“å‰åŠ è½½çš„æ‰€æœ‰æ—¥å¿—ä¸­æœç´¢ã€‚"

        self.ai_assistant.chat_panel.question_var.set(question)
        self.ai_assistant.ask_question()

    def copy_selected_text(self) -> None:
        """å¤åˆ¶é€‰ä¸­çš„æ–‡æœ¬"""
        try:
            if self.app.log_text.tag_ranges("sel"):
                selected_text = self.app.log_text.get("sel.first", "sel.last")
                self.app.root.clipboard_clear()
                self.app.root.clipboard_append(selected_text)
        except Exception as e:
            print(f"å¤åˆ¶æ–‡æœ¬å¤±è´¥: {str(e)}")

    def search_selected_text(self) -> None:
        """æœç´¢é€‰ä¸­çš„æ–‡æœ¬"""
        try:
            if self.app.log_text.tag_ranges("sel"):
                selected_text = self.app.log_text.get("sel.first", "sel.last").strip()
                if selected_text:
                    self.app.search_var.set(selected_text)
                    self.app.search_logs()
        except Exception as e:
            print(f"æœç´¢æ–‡æœ¬å¤±è´¥: {str(e)}")

    def setup_navigation_shortcuts(self) -> None:
        """è®¾ç½®å¯¼èˆªå¿«æ·é”®"""
        try:
            # Ctrl+[ : åé€€
            self.app.root.bind_all("<Control-bracketleft>", self._shortcut_go_back)
            # Ctrl+] : å‰è¿›
            self.app.root.bind_all("<Control-bracketright>", self._shortcut_go_forward)
            # Ctrl+G : è·³è½¬åˆ°æŒ‡å®šè¡Œ
            self.app.root.bind_all("<Control-g>", self._shortcut_goto_line)
            # Ctrl+M : æ¸…é™¤æ‰€æœ‰æ ‡è®°
            self.app.root.bind_all("<Control-m>", self._shortcut_clear_marks)

            print("âœ… å¯¼èˆªå¿«æ·é”®å·²è®¾ç½®: Ctrl+[ (åé€€) | Ctrl+] (å‰è¿›) | Ctrl+G (è·³è½¬) | Ctrl+M (æ¸…é™¤æ ‡è®°)")

        except Exception as e:
            print(f"âš ï¸  è®¾ç½®å¯¼èˆªå¿«æ·é”®å¤±è´¥: {e}")

    def _shortcut_go_back(self, event=None) -> str:
        """å¿«æ·é”®: åé€€"""
        if self.navigator:
            if self.navigator.go_back():
                self._show_status_message("â¬…ï¸  åé€€")
            else:
                self._show_status_message("âš ï¸  æ²¡æœ‰æ›´æ—©çš„å†å²è®°å½•")
        else:
            self._show_status_message("âš ï¸  å¯¼èˆªå™¨æœªåˆå§‹åŒ–")
        return "break"  # é˜»æ­¢äº‹ä»¶ç»§ç»­ä¼ æ’­

    def _shortcut_go_forward(self, event=None) -> str:
        """å¿«æ·é”®: å‰è¿›"""
        if self.navigator:
            if self.navigator.go_forward():
                self._show_status_message("â¡ï¸  å‰è¿›")
            else:
                self._show_status_message("âš ï¸  æ²¡æœ‰æ›´æ–°çš„å†å²è®°å½•")
        else:
            self._show_status_message("âš ï¸  å¯¼èˆªå™¨æœªåˆå§‹åŒ–")
        return "break"

    def _shortcut_goto_line(self, event=None) -> str:
        """å¿«æ·é”®: è·³è½¬åˆ°æŒ‡å®šè¡Œ"""
        from tkinter import simpledialog

        line_num = simpledialog.askinteger(
            "è·³è½¬åˆ°è¡Œ",
            "è¯·è¾“å…¥è¡Œå·:",
            parent=self.app.root,
            minvalue=1
        )

        if line_num and self.navigator:
            if self.navigator.jump_to_line(line_num, reason="å¿«æ·é”®è·³è½¬"):
                self._show_status_message(f"âœ“ å·²è·³è½¬åˆ°ç¬¬ {line_num} è¡Œ")
            else:
                self._show_status_message(f"âœ— è·³è½¬å¤±è´¥")
        return "break"

    def _shortcut_clear_marks(self, event=None) -> str:
        """å¿«æ·é”®: æ¸…é™¤æ‰€æœ‰æ ‡è®°"""
        if self.navigator:
            self.navigator.clear_marks()
            self._show_status_message("âœ“ å·²æ¸…é™¤æ‰€æœ‰æ ‡è®°")
        else:
            self._show_status_message("âš ï¸  å¯¼èˆªå™¨æœªåˆå§‹åŒ–")
        return "break"

    def _show_status_message(self, message: str, duration: int = 3000):
        """åœ¨çŠ¶æ€æ æ˜¾ç¤ºæ¶ˆæ¯"""
        try:
            if hasattr(self.app, 'file_stats_var'):
                # ä¿å­˜åŸå§‹çŠ¶æ€
                original_status = self.app.file_stats_var.get()

                # æ˜¾ç¤ºæ¶ˆæ¯
                self.app.file_stats_var.set(message)

                # 3ç§’åæ¢å¤
                self.app.root.after(duration, lambda: self.app.file_stats_var.set(original_status))
            else:
                print(message)
        except Exception as e:
            print(f"æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

    def show_problem_graph(self):
        """æ˜¾ç¤ºé—®é¢˜é“¾è·¯å›¾"""
        if not SMART_FEATURES_AVAILABLE:
            messagebox.showinfo("æç¤º", "æ™ºèƒ½åŠŸèƒ½æœªå¯ç”¨")
            return

        if not self.navigator:
            messagebox.showinfo("æç¤º", "å¯¼èˆªå™¨æœªåˆå§‹åŒ–")
            return

        if not self.navigator.problem_graph:
            messagebox.showinfo("æç¤º", "æš‚æ— é—®é¢˜èŠ‚ç‚¹\n\nAIåˆ†ææ—¥å¿—åä¼šè‡ªåŠ¨åˆ›å»ºé—®é¢˜é“¾è·¯")
            return

        try:
            from .ai_diagnosis.problem_graph_viewer import ProblemGraphViewer

            # åˆ›å»ºå¹¶æ˜¾ç¤ºå›¾å½¢æŸ¥çœ‹å™¨
            viewer = ProblemGraphViewer(self.app.root, self.navigator)

        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"æ— æ³•æ‰“å¼€é—®é¢˜é“¾è·¯å›¾: {str(e)}")
            import traceback
            traceback.print_exc()

    def show_cache_dashboard(self):
        """æ˜¾ç¤ºç¼“å­˜ç»Ÿè®¡ä»ªè¡¨æ¿"""
        if not SMART_FEATURES_AVAILABLE:
            messagebox.showinfo("æç¤º", "æ™ºèƒ½åŠŸèƒ½æœªå¯ç”¨")
            return

        if not self.analysis_cache:
            messagebox.showinfo("æç¤º", "ç¼“å­˜æœªåˆå§‹åŒ–")
            return

        try:
            from .ai_diagnosis.cache_dashboard import CacheDashboard

            # åˆ›å»ºå¹¶æ˜¾ç¤ºä»ªè¡¨æ¿
            dashboard = CacheDashboard(self.app.root, self.analysis_cache)

        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"æ— æ³•æ‰“å¼€ç¼“å­˜ç»Ÿè®¡: {str(e)}")
            import traceback
            traceback.print_exc()
