"""
iOS混淆工具 - 参数说明内容

存储参数说明对话框显示的完整内容，
从obfuscation_tab.py中提取以减少主文件大小。
"""

# 参数说明内容
PARAMETER_HELP_CONTENT = """

=== 基本混淆选项 ===

📝 类名混淆
• 说明：将项目中的类名（如 UserManager）替换为随机字符串（如 WHC8kF3x）
• 适用场景：
  - 应对App Store机器审核（4.3问题）
  - 隐藏业务逻辑类名
  - 防止代码逆向分析
• 示例：
  原始：@interface UserManager : NSObject
  混淆：@interface WHC8kF3x : NSObject
• ⚠️ 注意：系统类（如UIViewController）和第三方库类会自动跳过

📝 方法名混淆
• 说明：将自定义方法名替换为随机字符串
• 适用场景：
  - 隐藏核心业务方法
  - 防止Hook和Method Swizzling
  - 增加逆向难度
• 示例：
  原始：- (void)loadUserData;
  混淆：- (void)WHCm9K2p;
• ⚠️ 注意：
  - 系统方法（如viewDidLoad）自动跳过
  - Runtime动态调用的方法需加入白名单

📝 属性名混淆
• 说明：将@property声明的属性名替换为随机字符串
• 适用场景：
  - 保护数据模型定义
  - 隐藏关键属性名
• 示例：
  原始：@property (nonatomic, strong) NSString *userName;
  混淆：@property (nonatomic, strong) NSString *WHCp3X7k;
• ⚠️ 注意：KVO/KVC使用的属性名需加入白名单

📝 协议名混淆
• 说明：将@protocol协议名替换为随机字符串
• 适用场景：
  - 隐藏模块间通信协议
  - 保护架构设计
• 示例：
  原始：@protocol DataSourceDelegate <NSObject>
  混淆：@protocol WHC5pN8m <NSObject>
• ⚠️ 注意：系统协议（如UITableViewDelegate）自动跳过


=== 资源处理选项 ===

🎨 XIB/Storyboard处理
• 说明：同步更新XIB和Storyboard文件中引用的类名
• 适用场景：
  - 项目使用XIB或Storyboard布局
  - 确保界面加载不出错
• 工作原理：
  - 扫描XIB/Storyboard文件
  - 查找customClass属性
  - 替换为混淆后的类名
• ✅ 必须启用：使用XIB/Storyboard的项目

🎨 图片像素修改
• 说明：修改图片文件的像素值，改变文件hash但不影响视觉效果
• 适用场景：
  - 应对2.1审核问题（重复资源检测）
  - 每次提审使用不同的图片hash
• 强度参数：
  - 0.005-0.01：轻微修改（推荐）
  - 0.02-0.05：中等修改
  - 0.10：强烈修改（可能影响视觉）
• ⚠️ 注意：修改前请备份原图，建议先在测试设备验证

🎨 音频hash修改
• 说明：修改音频文件元数据，改变hash但不影响播放
• 适用场景：
  - 应对重复资源检测
  - 音频文件版本管理
• ⚠️ 注意：建议在非关键音效上使用

🎨 字体文件处理
• 说明：修改字体文件元数据
• 适用场景：
  - 自定义字体文件去重
  - 字体资源混淆
• ⚠️ 注意：修改后测试字体渲染是否正常

🎨 自动添加到Xcode
• 说明：自动将生成的垃圾代码和字符串解密文件添加到Xcode项目中
• 适用场景：
  - 启用了垃圾代码生成或字符串加密
  - 希望自动化混淆流程，无需手动拖拽文件
• 依赖要求：
  - 需要安装mod-pbxproj库：pip install pbxproj
  - 或在虚拟环境中：source venv/bin/activate && pip install pbxproj
• 工作原理：
  - 使用pbxproj库修改.xcodeproj项目文件
  - 自动添加垃圾代码文件到Obfuscation/GarbageCode组
  - 自动添加解密头文件到Obfuscation/StringDecryption组
• 如果未安装pbxproj库：
  - 混淆功能正常运行
  - 文件会正常生成到输出目录
  - 但不会自动添加到Xcode项目
  - 需要手动将文件拖拽到Xcode项目中
• 生成的文件位置：
  - 垃圾代码：输出目录/Obfuscation/GarbageCode/
  - 解密文件：输出目录/Obfuscation/StringDecryption/
• 💡 提示：
  - 点击复选框旁的ℹ️按钮可查看实时库状态
  - 建议安装pbxproj库实现完全自动化
  - 首次使用可以不安装，手动添加文件体验流程
• ⚠️ 注意：仅在启用垃圾代码或字符串加密时需要此功能


=== 高级选项 ===

⚡ 自动检测第三方库
• 说明：自动识别CocoaPods、SPM、Carthage管理的第三方库，加入白名单
• 适用场景：
  - 使用了第三方库（如AFNetworking、SDWebImage等）
  - 避免混淆第三方代码导致崩溃
• 检测方式：
  - CocoaPods：扫描Podfile.lock
  - SPM：扫描Package.resolved
  - Carthage：扫描Cartfile.resolved
• ✅ 推荐始终启用

⚡ 确定性混淆
• 说明：使用固定种子生成混淆名称，保证每次混淆结果相同
• 适用场景：
  - 版本迭代时保持符号名称不变
  - 便于bug定位和崩溃追踪
  - 增量混淆（仅混淆新增代码）
• 工作原理：
  - 固定随机数种子
  - 相同输入产生相同输出
  - 新版本使用旧版本映射文件
• 💡 提示：配合"导出映射"功能使用


=== 命名配置 ===

🔤 命名策略
• random（随机）：
  - 完全随机字符串
  - 最高安全性
  - 示例：MyClass → FkLpQwXy

• prefix（前缀）：
  - 固定前缀+随机字符
  - 便于识别混淆符号
  - 示例：MyClass → WHCjkdF8x

• pattern（模式）：
  - 按规则生成（前缀+类型+序号）
  - 便于管理和追踪
  - 示例：MyClass → WHCC001

• dictionary（词典）：
  - 使用英文单词组合
  - 更自然的命名
  - 示例：MyClass → TigerFast

🔤 名称前缀
• 说明：混淆后符号名称的统一前缀（2-5个字符）
• 适用场景：
  - 区分混淆代码和原始代码
  - 快速识别混淆符号
  - 避免与系统符号冲突
• 示例：
  - WHC：常用前缀
  - ABC：公司缩写
  - MP：项目缩写
• 💡 提示：建议使用大写字母，避免与系统前缀冲突

🎨 图片修改强度
• 说明：控制图片像素修改的幅度（0.005-0.10）
• 推荐值：
  - 0.01：最安全，几乎无视觉影响
  - 0.02：标准值，适合大多数场景
  - 0.05：较强修改，建议测试
• 💡 提示：值越大，hash变化越大，但视觉影响也越大


=== 快速配置模板 ===

⚡ 最小化
• 适用场景：快速测试、调试阶段
• 混淆内容：仅类名和方法名
• 资源处理：不处理
• 推荐用于：开发和测试阶段

⚡ 标准
• 适用场景：日常开发、小版本更新
• 混淆内容：类名、方法名、属性名、协议名
• 资源处理：不处理
• 推荐用于：一般提审场景

⚡ 激进
• 适用场景：正式发布、应对4.3和2.1审核
• 混淆内容：所有符号
• 资源处理：图片、音频、字体全处理
• 推荐用于：重要版本发布


=== P2高级混淆选项 🆕 ===

⚡ 插入垃圾代码
• 说明：在项目中生成无用但合法的垃圾类和方法，增加代码复杂度
• 适用场景：
  - 应对4.3代码相似度检测
  - 增加逆向分析难度
  - 掩盖真实代码逻辑
• 参数配置：
  - 垃圾类数：生成垃圾类的数量（5-100），建议20-30个
  - 复杂度：simple（简单）/moderate（中等）/complex（复杂）
  - 调用关系：启用后垃圾类之间会相互调用，更真实
• ⚠️ 注意：数量过多会增加编译时间和包体积

⚡ 垃圾代码调用关系 🔗
• 说明：让垃圾类之间建立真实的调用关系，使其看起来更像正常代码
• 适用场景：
  - 提升垃圾代码的真实性
  - 防止静态分析识别垃圾代码
  - 增强混淆效果
• 参数配置：
  - 调用关系：勾选启用垃圾类之间的调用关系
  - 调用密度：控制调用关系的多少
    * low（稀疏）：每个类调用1-2个其他类
    * medium（中等）：每个类调用3-5个其他类（推荐）
    * high（密集）：每个类调用6-10个其他类
• 工作原理：
  - 自动生成类之间的方法调用代码
  - 支持三种调用模式：直接调用/条件调用/循环调用
  - 同时支持Objective-C和Swift
• 💡 提示：默认启用medium密度即可，无需调整
• ⚠️ 注意：密度过高会略微增加编译时间

⚡ 字符串加密
• 说明：加密代码中的字符串常量，运行时自动解密
• 适用场景：
  - 保护敏感信息（API密钥、URL等）
  - 防止字符串常量泄露
  - 增加逆向难度
• 参数配置：
  - 加密算法：xor（异或）/base64/shift/rot13/aes128 🆕/aes256 🆕
  - 最小长度：只加密长度≥此值的字符串（1-20）
  - 加密白名单：点击"🛡️ 加密白名单"按钮管理
• 加密算法对比：
  - **xor**: 异或加密，安全性和性能平衡好（推荐日常使用）
  - **base64**: Base64编码，轻量但安全性较低
  - **shift**: 移位加密，简单快速
  - **rot13**: ROT13编码，最简单
  - **aes128**: AES-128加密，高安全性，适合敏感数据 🆕
  - **aes256**: AES-256加密，最高安全性，适合核心数据 🆕
• 推荐值：
  - 算法：
    - 普通场景：xor（安全性和性能平衡）
    - 敏感信息：aes128（高安全性）
    - 核心数据：aes256（最高安全性）
  - 最小长度：4-6（避免加密过多短字符串）
• ⚠️ 注意：
  - 加密后会自动生成解密代码，需手动添加到Xcode项目
  - AES算法需要PyCryptodome库：pip install pycryptodome
  - AES加密比XOR稍慢，但安全性显著提升

🔐 AES加密算法详解 🆕

• **AES-128（高级加密标准-128位）**:
  - 说明：使用128位密钥的AES对称加密算法
  - 安全性：军用级加密强度，NSA认证
  - 性能：加密速度适中，适合移动设备
  - 原理：
    - 使用MD5从密钥字符串生成16字节密钥
    - CBC模式（密码块链接模式）
    - PKCS7填充对齐块大小
    - 随机IV（初始化向量）增强安全性
  - 适用场景：
    - API密钥、Token等敏感字符串
    - 支付密码、用户凭证
    - 中等重要性的业务数据
  - 解密方式：使用iOS原生CommonCrypto框架
  - 性能影响：比XOR慢约2-3倍，但安全性提升10倍以上

• **AES-256（高级加密标准-256位）**:
  - 说明：使用256位密钥的AES对称加密算法
  - 安全性：最高级别商用加密，NSA Top Secret认证
  - 性能：加密速度比AES-128略慢，但仍可接受
  - 原理：
    - 使用SHA256从密钥字符串生成32字节密钥
    - CBC模式（密码块链接模式）
    - PKCS7填充对齐块大小
    - 随机IV（初始化向量）增强安全性
  - 适用场景：
    - 核心业务逻辑加密
    - 金融交易相关数据
    - 最高机密级别字符串
  - 解密方式：使用iOS原生CommonCrypto框架
  - 性能影响：比XOR慢约3-4倍，但提供最强安全保护
  - 💡 提示：如果不确定选哪个，优先选AES-128，性能和安全性都足够

• **AES vs 其他算法对比**:
  | 特性 | XOR | Base64 | AES-128 | AES-256 |
  |------|-----|--------|---------|---------|
  | 安全性 | ⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
  | 加密速度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
  | 破解难度 | 低 | 极低 | 极高 | 极高 |
  | 使用场景 | 一般数据 | 临时编码 | 敏感数据 | 核心数据 |
  | 密钥管理 | 简单 | 无需密钥 | 简单 | 简单 |
  | iOS支持 | 自实现 | 自实现 | 系统框架 | 系统框架 |

• **使用建议**:
  - ✅ 普通字符串（UI文本、日志等）：使用xor或base64
  - ✅ 敏感信息（API密钥、Token）：使用aes128
  - ✅ 核心数据（支付密码、核心逻辑）：使用aes256
  - ⚠️ 不要对所有字符串都用AES，会影响性能
  - 💡 建议：80%用xor，15%用aes128，5%用aes256


=== 白名单管理 ===

🛡️ 自定义白名单（符号白名单）
• 说明：指定不希望被混淆的符号（类名、方法名、属性名等）
• 使用场景：
  1. Runtime动态调用的方法
  2. JSBridge接口方法
  3. 配置文件中硬编码的类名
  4. 通知名称常量
  5. 第三方SDK要求保留的符号
• 操作方式：
  - 点击"🛡️ 管理白名单"按钮
  - 添加需要保护的符号
  - 填写添加原因（便于后期维护）
• 💡 提示：合理使用白名单，避免过度保护

🛡️ 字符串加密白名单 🆕
• 说明：指定不希望被加密的字符串常量
• 使用场景：
  1. 系统API名称（如"viewDidLoad"、"tableView"等）
  2. 第三方SDK方法名（用于Runtime调用）
  3. 通知名称（NSNotificationName）
  4. KVO/KVC使用的键名
  5. 配置键名（UserDefaults、Plist等）
  6. URL Scheme名称
• 操作方式：
  - 点击"🛡️ 加密白名单"按钮（字符串加密配置区域）
  - 添加需要保护的字符串
  - 填写备注说明（便于后期维护）
  - 支持导入/导出白名单（JSON或文本文件）
• 💡 提示：
  - 系统API相关字符串建议加入白名单
  - 白名单中的字符串不会被加密，保持原样
  - 可批量导入常用白名单（如系统方法名列表）


=== 使用建议 ===

✅ 新手建议
1. 首次使用选择"标准"模板
2. 不要修改资源文件（避免不确定性）
3. 混淆后完整测试所有功能
4. 保存映射文件（用于定位崩溃）

✅ 进阶使用
1. 启用"确定性混淆"保持版本一致性
2. 合理使用白名单保护关键符号
3. 根据审核情况调整混淆力度
4. 定期清理不需要的白名单项

⚠️ 重要提醒
• 混淆前务必备份原始代码
• 混淆后进行完整的功能测试
• 保存好映射文件（mapping.json）
• 第一次混淆建议使用"标准"模板
• Runtime动态调用的方法需加白名单

💡 最佳实践
• 开发阶段：使用"最小化"模板快速测试
• 测试阶段：使用"标准"模板验证功能
• 发布阶段：使用"激进"模板最大混淆
• 版本迭代：启用"确定性混淆"保持一致性

"""
